* Autothread


  Recursively resumes [[Responses][@/response]].


** The Challenge

  Our asynchronous functions yield a response, which they later call.  This
works right up until we try to do something else with coroutines, then it
falls flat.

The middle layer of the solution uses coroutine nests, and the top and bottom
use =autothread=.


*** Autothread

  Autothread either makes or resumes a coroutine, and handles three cases:

- Returning at the end of a successful execution

- Throwing errors

- Threading a Response

Barring those, it yields everything it got back (excepting the ok), making it
suitable as a middleware (or more likely for us, surfacing an error in the
code by attempting to yield the main thread).


*** The Next Challenge

  Autothread is fine and dandy, but some application will call for a custom
threading handler at some point.

Never mind why, there are a bunch of neat things we can do, but the point is
that then, and not now, we'll need to add the ability to pass the custom
threader in the Response instead of autothread.

Meanwhile, this will repeatedly restart nested coroutines when an async
module yields a Response, and that's why we need it to do.


#!lua
local create, status = assert(coroutine.create), assert(coroutine.status)
local yield, resume = assert(coroutine.yield), assert(coroutine.resume)

local function autothread(thread, ...)
   local work;
   if type(thread) == 'thread' then
      work = thread
   elseif type(thread) == 'function' then
      work = create(thread)
   else -- if thread isn't callable this will break
      work = create(function(...)
                       return thread(...)
                    end)
   end
   local res = pack(resume(work, ...))
   local ok, response, state = res[1], res[2], status(work)
   if ok and state == 'dead' then
      return select(2, unpack(res))
   elseif not ok then
      error(response)
   elseif type(response) == 'table' and response.isResponse then
      response.work = work
   else
      yield(select(2, unpack(res)))
   end

   return nil
end
#/lua

#!lua
return autothread
#/lua
