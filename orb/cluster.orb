* Cluster


  *The Comprehensive LUa System for Typing Everything Repeatedly*.

Cluster is the basis for using the LuaJIT runtime in the bridge-approved
fashion.  It succeeds at this, insofar as it will, by respecting the existing
[[philosophy][@#philosophy]] of the language.


** House Style for Cluster

  Because Cluster is new, the interface is unstable.  To keep refactoring
simple, we don't want to follow the localizing policy which is generally in
force, and we want to require it consistently as =cluster=.  I use =clu= in
helm, but absent static analysis tools which are nascent at best, keeping it
greppable is going to help. =cluster.ur.pass= is distinctive and we wouldn't
miss a reference to it if, say, =ur= changed name, however unlikely that
particular case might be.


** Rationale

  Lua is a minimalist programming language.  What other dynamic-interpreted
languages tend to do with classes, Lua does with hash maps, and a clever
system which the Lua authors call "metasyntactic extension".

Moonscript is an existence proof that one may implement a familiar object
system in Lua, with good performance and reasonable developer satisfaction.

Bridge has gone in a different direction.  One strength of a minimalist
language is that you only have to pay for what you need.

Most modules in bridge follow a simple module / instance format, and we
represent this intention using a simple function called =meta=.

The basic pattern is to make a table where ==tab.__index = tab==, fill this
table with methods, define =new= to construct an instance with this metatable,
set ==tab.idEst = new==, then return it.

This gives us the necessary affordances to build, but requires shenanigans to
do even single inheritance, because we need to instantiate the module to get
at the metatable in order to extend it.

Worse, using an =.idEst= slot on the indexed metatable allows for exactly one
sort of identity.  I've lampshaded this weakness by using e.g.
==isNode = true== as a 'genus', which is adequate but not actually good;
continuing to ad-hoc our way through identity and interface is a recipe for
pain.

The goal here is to develop a meta-object protocol, which allows the user to
build various rich abstractions, while requiring only minimal changes to the
80% of modules which returns a function that assigns a metatable.


*** Moving Past Single-Inheritance Through Self Tables

  One pattern which isn't carrying its weight is what we've been calling self
tables.  These are the return value of =meta {}=, such that a sequence such
as:

#!lua #noKnit #example
Widget = meta {}

-- here we fill the widget table

SubWidget = meta(Widget)
#/lua

Will... usually give expected results.


**** A close reading of core.cluster.meta

It's worth looking at the current version of meta.  We don't have transclusions
yet, so it's copy and paste, alas.  This is /mostly/ the basis for inheritance
and instantiation patterns in bridge, although not entirely.

#!lua #noKnit #example #hashtagTranscludeMe
function cluster.meta(Meta)
   Meta = Meta or {}

   -- decoration
   if Meta
      and type(Meta) == 'table'
      and isempty(Meta) then

      Meta.__index = Meta
      return Meta
   end

   -- inheritance
   if Meta and Meta.__index then
      local tab = {}
      for field, value in next, Meta, nil do
         if sub(field, 1, 2) == "__" then
            tab[field] = value
         end
      end
      if Meta.__meta then
         tab.__meta = tab.__meta or {}
         for _, __ in next, Meta.__meta, nil do
            tab.__meta[_] = __
         end
      end
      tab.__index = tab
      return setmeta(tab, Meta)
   end

   error ("cannot make metatable from type" .. type(Meta))
end
#/lua

See that =meta= does the same thing called as =meta()=, and our preferred form
=meta {}=. I will argue that this at least is a good pattern. Instantiation
of a table without arguments looks nicer in the form =build {}=, and
=build ()= should have the same behavior.

The self-indexing pattern avoids creating a separate index table and metatable,
which in the simple module-instance pattern obscures more than it illuminates.

The statement beginning =if Meta.__meta then= is not currently used anywhere,
it's a sketch in the direction of an extension of the existing system.


*** Seed, Cassette, Meta

  We need a constructor which can double as an identity for any table which is
specialized from the genus we're defining, as well as a table we can define
methods and other fields on such that lookup on an instance will return those
values.  We've handled this with ==new, idEst, and Tab.__index = Tab==, and
it isn't enough.

The return value we'll call a *Seed*.  This is a table with a call metamethod
which constructs an instance, and the Cassette as the index metatable, and is
the return value of our familiar sort of module.  Probably this should be
read only as well.

The Cassette is a table which is expected to be indexed against /in some way/
by instances, and in the easy case, this has the usual single inheritance by
metatable pattern.  It is /not/ a self table, and it is normally but not
always the =__index= table of the Meta.  The reference is to gene cassettes,
which if you know what a chromosome is, that's close enough to get the gist.

The Meta is assigned by the constructor to an instance table as the last step
in instantiating a table.  We've been doing this backward, which is
forgiveable as the clearest reading of a function, but as we'll see, this
inhibits composition, not to mention the occasional shallow bug from doing
things in the constructor which are given different meanings by the metatable.

So a completely blank canvas has these relations:

#!lua #noKnit
local Seed, Cassette, Meta = setmeta({}, {}), {}, {__meta = {}}

getmeta(Seed).__index = Cassette

Meta.__index = Cassette

Meta.__meta.__seed = Seed
#/lua

Although not created out in the open like that.

In a real program this will look more like any other day at the widget
factory:

#!lua #noKnit #Example
local new, Widget, Widget_M = cluster.genus()
#/lua

After which Widget is assigned the usual collection of methods and base
values, and new is returned after a constructor is created.

Capturing the third value (Meta) is optional, so unless there are metamethods
to be provided or extended, it can just be ==local new, Widget = ...==.

The secret sauce here is that =cluster:cluster= contains a private library of
everything which passes through it.

So let's give this a go.


*** cluster


**** Localize All The Things

  Cluster takes the unusual step of localizing everything, even single-name
globals.  It's not unheard of elsewhere in the code, we use the pattern in
Grammar.

#!lua
local assert = assert
local require = assert(require)
local error   = assert(error)
local getmeta, setmeta = assert(getmetatable), assert(setmetatable)
-- I'm going to shadow these because I'll forget otherwise
local getmetatable, setmetatable = nil, nil
#/lua


#!lua
local core = require "qor:core"
#/lua

#!lua
local cluster = {}
#/lua


**** cluster weak table library

   Cluster observes everything which passes through it, by saving weak
references.

#!lua
local weak = assert(core.meta.weak)
#/lua

Seed, cassette, and meta, have a sort of primitive component type, so cluster
will want to be able to tell which it might be dealing with when handed a
given table.

So we need three weak tables for this purpose:

#!lua
local is_seed, is_tape, is_meta = weak 'k', weak 'k', weak 'k'
#/lua

As a quirk, we call cassettes "tape" inside cluster.  My excuse is that the
concept map from the cassette-in-itself to the word "cassette" is at least
translucent, and that cassette-to-tape is also easy enough.  This relies on a
pun, though, and offering it to the user as a Tape would be misleading.

It is, moreover, a long word, and without going full Mencius "Procrustes"
Moldbug on our vocabulary, the trio of four-letter variables makes for
pleasing code.

The three parts being inter-related, we also map between them:

#!lua
local seed_tape, tape_seed = weak 'kv', weak 'kv'
local tape_meta, meta_tape = weak 'kv', weak 'kv'
local meta_seed, seed_meta = weak 'kv', weak 'kv'
#/lua

We want a function to do all this bookkeeping for us:

#!lua
local insert = assert(table.insert)

local function register(seed, tape, meta)
   is_seed[seed] = true
   is_tape[tape] = true
   is_meta[meta] = true
   seed_tape[seed] = tape
   tape_seed[tape] = seed
   tape_meta[tape] = meta
   meta_tape[meta] = tape
   meta_seed[meta] = seed
   seed_meta[seed] = meta
   return seed, tape, meta
end
#/lua

I'm just adding a quick note that we can call these an =observer= and
=translator= and make them methodical.


** idest(obj, pred)

This is one of, if not the most, pervasive elements of Cluster.

So much so that we globalize it at load time.

This initial implementation does three things:

-  If =pred= is a string, it is assumed to be a primitive type.
   Warning: we may do cdata detection and use metatype stuff there, at some
   future point.

-  If the object is a table, we first try cluster-style single inheritance,
   falling back on old-school =meta {}= style self tables.

#!lua #noKnit
local function idest(obj, pred)
   -- primitive
   if type(pred) == 'string' then
      return type(obj) == pred
   end
   -- try new-style first
   if type(obj) == 'table' then
      local _M = getmetatable(obj)
      if _M and is_meta[_M] then
         while _M do
            if _M.__meta.seed == pred then
               return true
            end
            _M = _M.__meta.meta
         end
      elseif obj.idEst == pred then
         return true
      end
   end

   return false
end

rawset(getfenv(1), "idest", idest)
#/lua


** order, genus, and species


*** order(contract?)

This is a refactor, because I did the simpler thing and made =genus= itself
nullable.

And I might keep that, because the idea that an empty order does what genus
does right now if called with no arguments is valid.

The idea here is that calling order with a table (or it might be a function)
will configure it according to the Cluster /contract/, which is a thing we
don't have yet.

=order= will come first, but our initial definition will forbid an argument so
that we can prefer it over genus for new orders.


*** genus(family: seed?)

This either creates or extends a genus.

Why genus?  It gives us some climbing room before we bump up on class, for one
thing.

It's also a reminder that we are using the techniques of prototyping and the
metaobject protocol.

Last, it's a reminder that applying it repeatedly gives /generic/ results, and
this is paired with =specialize=, as we shall see.

Note that with three return values, offering =genus {}= would be a confusing
interface.

#!lua
local pairs = assert(pairs)

local function genus(family)
   local seed, tape, meta = register({}, {}, {})
   meta.__meta = {}
   setmeta(seed, { __index = tape })
   if family then
      assert(is_seed[family], "provide constructor to extend genus")
      local meta_tape = seed_tape[family]
      setmeta(tape, { __index = meta_tape })
      local _M = seed_meta[family]
      for k, v in pairs(_M) do
         -- meta we copy
         if k == '__meta' then
            for _, __ in pairs(v) do
              meta.__meta[_] = __
            end
         else
            meta[k] = v
         end
      end
      meta.__meta.meta = _M -- ... yep.
   end
   meta.__index = tape
   meta.__meta.seed = seed
   return seed, tape, meta
end

cluster.genus = genus
#/lua

#!lua
local function order(no_table)
   if no_table then
      error "calling cluster.order with a contract is NYI"
   end
   return genus()
end

cluster.order = order
#/lua


**** cluster.species(specimen?)

Unwritten, replacement for the =meta {}= pattern.

Called =species= because opportunities for extension are limited.  Will use
a self-table pattern, but registered with =cluster=, and designed so that a
species can be promoted to an order without needing to modify user code.


*** construct(seed, builder)

This being a decorator, it returns nothing.


**** Signature of builder: builder(seed, instance, ...) -> instance

In order to successfully extend builders, they can neither create the instance
nor assign it a metatable.

The result of calling =construct= is a callable with the signature
=(seed, ...) -> Instance =, so the builder signature is
=(seed, instance, ...) -> instance=.

The builder *must not* assign a metatable, because the JIT relies on immutable
table/metatable relationships, and even if it didn't, assigning intermediate
metatable which are never used is sloppy engineering.

The seed and the metatable have the same index, so it's possible to use
values from the cassette during building, whether that's a good idea or not.

The user must bear in mind that selecting slots from the seed means that
extensions will be able to change the values.  The builder function is
normally closed over the Cassette (as well as the Seed and Meta) and can
choose to incorporate those values instead.

Cluster takes care of making the builder into a constructor by making the object
and composing an
assignment of the metatable with the builder function.

This separation lets us re-use the builder in specializing a given genus, if
we want to, without performing the forbidden double-metatable assignment.

#!lua
local compose = assert(core.fn.compose)

local function makeconstructor(builder, meta)
   return function(seed, ...)
      local instance = {}
      return setmeta(builder(seed, instance, ...), meta)
   end
end

local function construct(seed, builder)
   assert(is_seed[seed], "#1 to construct must be a seed")
   -- assert(iscallable(builder), "#2 to construct must be callable")
   local meta = assert(seed_meta[seed], "missing metatable for seed!")
   meta.__meta.builder = builder
   getmeta(seed).__call = makeconstructor(builder, meta)

   return;
end

cluster.construct = construct
#/lua

Here we see how using a local library of weak references can mitigate the
complexity of having three tables floating around.  We don't need to hand
back the metatable when adding the constructor, which is just an opportunity
to pass the cassette by accident.


**** extendbuilder(seed, builder)

  This performs the 'natural' extension of a builder function, by passing the
seed, instance, and all argument, first to the super builder, then to the new
builder.

#!lua
local function extendbuilder(seed, builder)
   assert(is_seed[seed], "#1 to construct must be a seed")
   local meta = assert(seed_meta[seed], "missing metatable for seed")
   local _M = meta.__meta.meta
   if not _M then
      error("can't extend a constructor with no inheritance, use construct")
   end

   local super_build = assert(_M.__meta.builder, "metatable missing a builder")
   local function _build(seed, instance, ...)
      local _inst = super_build(seed, instance, ...)
      return builder(seed, _inst, ...)
   end
   meta.__meta.builder = _build

   getmeta(seed).__call = makeconstructor(_build, meta)
end

cluster.extendbuilder = extendbuilder
#/lua

This interface is experimental, to put it mildly, this is just a hunch:

#!lua
cluster.extend = {}
cluster.extend.builder = extendbuilder
#/lua


*** super(tape, "message", after_method)

The signature we want is =super(tape):message(after_method)=, but let's
work our way up.

A MOP will offer a variety of extension protocols, but you'll see a theme,
which is that of pursuing a general and satisfactory single inheritance which
survives more than one round of specialization.

This relies on the tape being a reliable source of truth when looking up the
super method, which we will have to solve eventually. This is at least true
when we use the bog-standard =__index= chain of tables, and I want to write
the tricky functionalizing stuff against a need for it.

Note that this discards the value of the super method, which is compatible
with the chaining style and anything else where the return value may be
recomputed.


#!lua
local iscallable = assert(core.fn.iscallable)
local rawget = assert(rawget)
local function super(tape, message, after_method)
   assert(is_tape[tape], "#1 error: cluster.super extends a cassette")
   assert(type(message) == 'string', "#2 must be a string")
   assert(iscallable(after_method), "#3 must be callable")
   -- let's prevent this happening twice
   if rawget(tape, message) then
      error("cassette already has " .. message)
   end
   local super_method = tape[message]
   assert(iscallable(super_method))
   tape[message] = function(_tape, ...)
                      super_method(_tape, ...)
                      return after_method(_tape, ...)
                   end

   return;
end

cluster.super = super
cluster.extend.super = super
#/lua


*** Cluster .ur methods

These are primitive functions which provide suitable base-layer behaviors for
genera.

#!lua
local ur = {}
cluster.ur = ur
#/lua


*** mu()

This returns, regardless of argument.

#!lua
function ur.mu()
   return
end
#/lua


*** pass(...)

Returns all arguments.

#!lua
function ur.pass(...)
   return ...
end
#/lua


*** chain(a)

Returns only the first argument.

#!lua
function ur.chain(a)
   return a
end
#/lua


*** thru(_, ...), AKA through

Ignores /only/ the first argument, returning any others.

The shorter spelling is preferred, but synonyms are cheap and these two have
reference equality.

#!lua
function ur.thru(_, ...)
   return ...
end

ur.through = ur.thru
#/lua


**** NYI(!)

Throws an error if called.

#!lua
function ur.NYI()
   error "missing method!"
end
#/lua


**** yes(), no()

Respond =true= or =false= respectively.

Used to provide a /meaningful/ base response to a predicate message.  Prefer
=mu= or =NYI= if the predicate should or must be provided.

#!lua
function ur.no()
   return false
end
#/lua

#!lua
function ur.yes()
   return true
end
#/lua


#!lua
return cluster
#/lua

This represents an early and unstable sketch of Cluster, which we'll continue
to describe and design below.

** Philosophy

> We can divide programming languages in two categories:
>
>  1) Those where arrays start at 1.
>
>  1) Those where arrays start at 0.
>
> -- Roberto Ierusalimschy, 2022-01-01

   If Lua has a flaw, it is this, and here we might even see the maestro cop
to it.

So, as we must, we [[tip our hat to Edsger Djikstra]‡], as we dive back into
the waters of Knuthian programming with Wirthian characteristics.

[‡]: https://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF


***  Respect the Runtime

  Lua is a carefully designed language, and was chosen carefully by your
humble author, out of admiration for the choices which were made in this
design.

This applies even moreso to the choice of implementation, LuaJIT.  This brings
two offerings to the table: a powerful JIT and a wonderful foreign function
interface.


**** Meta-Object Protocol

  One of the attractions of Lua is that it embraces the correct definition of
"object" to use when programming anywhere near the C runtime.

This is more than just a particular layout of memory, pointer references can
make the instance of a particular object arbitrarily complex, but what an
object *is* to the C programmer needn't be defined to point out that Lua uses
it.

Clearly, associating tables with behavior is also core to the Lua philosophy,
but this is done in a way which the authors describe as metasyntactic
extension.  This is familiar to old Lisp hands as a meta-object protocol, a
set of abstractions which allow the dispatch of various messages to
appropriate responders through the same syntax used to access literal slots
on the table in question.


** Types

  Cluster progressively turns the LuaJIT runtime (with libuv and SQLite
characteristics) into a gradually typed system.

Type itself is heavily overloaded, and we have our work cut out in manifesting
something which gives us what we want with reasonable tradeoffs.

The easy to spot types in Lua are two: the first are the primitives, which are
what you get from calling =type=, plus a whole right world in the =ffi.cdef=
extension, which is from Lua's perspective just called =cdata=.

The second are what we might call relational types: any two tables which share
a common metatable are in an obvious relational harmony which can and should
be expressed through a type system.  Lua's metasyntactic extensions are a
natural fit for a certain sort of index-oriented module-and-instance pattern,
which bears up under a certain amount of careful single inheritance.


*** Angle of Attack

One of the superpowers we've unlocked with the Bridge is the ability to parse
Lua into an enriched AST within the language.  This should let us add a
fairly standard inferred type system based on the primitive Lua functions,
operators, and primitives, which is a start.

This is part of the Lun/Clu project, which is its own beast, but the Cluster
codex must be considered within that context.  What we are building is
fundamentally a set of runtime constraints on a dynamic language, designed to
allow the orthogonality of the basic primitives and concepts to compose nicely
into richer abstractions.

The intention is that this knowledge will be useful during several stages,
in order: compile time, comptime, load time, and runtime.  We necessarily work
backward toward that goal.


** Glossary

Words and concepts in the glossary are solid enough to define and refer to.

Everything which is still fluid or tentative is below, in [[Concepts]
[@#concepts]].e


*** Field

  A key/value pair, considered in terms of the *key*.  This is an efficient
rather than formal relation, that is, it is the /consequence/ of calling
=tab[field]= we are concerned with.  A field is a key if it lives on the
table being indexed, and it is by definition a key which is used to access
the corresponding value on the *slot*.  A field /defines/ the result of
=tab[field]= in right-hand positions, and /returns the lvalue/ for a statement
of the form ==tab[field] = slot==.


*** Slot

  A key/value pair, considered in terms of the *value*.  This is an efficient
rather than formal relation, that is, it is the /rvalue/ of (especially)
==tab[field] = slot== we are concerned with.  A slot may contain a value on
the table itself, or anywhere else.  It is the /return value/ of =tab[field]=
and the /rvalue/ of ==tab[field] = slot ==.


*** Message

  A **field**, correponding to a *slot* containing the function, expected to be
called with the *instance* as the first argument, normally in the sugared form
=tab:message(...)=.


*** Method

  A *callable* living on a slot of a table which is intended primarily to
receive that table as the first argument.  A **message** is to a *method* as
a **field** is to a **slot**.  The Actor framework provides a reified Message,
which is rightly seen as an extension of this concept.

We use =:message= shorthand when referring to fields which will return
methods.


** Concepts

  Cluster (rhymes with cluck) brings together a bewildering number of sources,
and out of bare necessity of discovery, I barely understand how it works now,
let alone once there is code in this repository.


*** Molds

  The question we're trying to answer with types, is what sorts of behaviors
and data a given object might contain or display.

In hoon, everyone's favorite acid trip, the mold is one of the ways of
grappling with this reality.

For our purposes, a mold is a way of constraining the rvalue of a given lvalue.
This returns either the value, which in the general case is an Any, or
=nil, condition=.  We'll talk about what conditions are and imply later, it's
a form of error, mostly.

