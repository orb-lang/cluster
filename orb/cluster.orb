* Cluster


  *The Comprehensive LUa System for Typing Everything Repeatedly*.

Cluster is the basis for using the LuaJIT runtime in the bridge-approved
fashion.  It succeeds at this, insofar as it will, by respecting the existing
[[philosophy][@#philosophy]] of the language.


** House Style for Cluster

  Because Cluster is new, the interface is unstable.  To keep refactoring
simple, we don't want to follow the localizing policy which is generally in
force, and we want to require it consistently as =cluster=.  I use =clu= in
helm, but absent static analysis tools which are nascent at best, keeping it
greppable is going to help. =cluster.ur.pass= is distinctive and we wouldn't
miss a reference to it if, say, =ur= changed name, however unlikely that
particular case might be.


*** Seed, Tape, Meta

  We need a constructor which can double as an identity for any table which is
specialized from the genus we're defining, as well as a table we can define
methods and other fields on such that lookup on an instance will return those
values.  We've handled this with ==new, idEst, and Tab.__index = Tab==, and
it isn't enough.

The return value we'll call a *Seed*.  This is a table with a call metamethod
which constructs an instance, and the Tape as the index metatable, and is
the return value of our familiar sort of module.  Probably this should be
read only as well.

The Tape is a table which is expected to be indexed against /in some way/
by instances, and in the easy case, this has the usual single inheritance by
metatable pattern.  It is /not/ a self table, and it is normally but not
always the =__index= table of the Meta.  The reference is to gene tapes,
which if you know what a chromosome is, that's close enough to get the gist.

The Meta is assigned by the constructor to an instance table as the last step
in instantiating a table.  We've been doing this backward, which is
forgiveable as the clearest reading of a function, but as we'll see, this
inhibits composition, not to mention the occasional shallow bug from doing
things in the constructor which are given different meanings by the metatable.

So a completely blank canvas has these relations:

#!lua #noKnit
local Seed, Tape, Meta = setmeta({}, {}), {}, {__meta = {}}

getmeta(Seed).__index = Tape

Meta.__index = Tape

Meta.__meta.__seed = Seed
#/lua

Although not created out in the open like that.

In a real program this will look more like any other day at the widget
factory:

#!lua #noKnit #Example
local new, Widget, Widget_M = cluster.order()
#/lua

After which Widget is assigned the usual collection of methods and base
values, and new is returned after a constructor is created.

Capturing the third value (Meta) is optional, so unless there are metamethods
to be provided or extended, it can just be ==local new, Widget = ...==.

The secret sauce here is that =cluster:cluster= contains a private library of
everything which passes through it.

So let's give this a go.


*** cluster


**** Localize All The Things

  Cluster takes the unusual step of localizing everything, even single-name
globals.  It's not unheard of elsewhere in the code, we use the pattern in
Grammar.

#!lua
local assert = assert
local require = assert(require)
local error   = assert(error)
local getmeta, setmeta = assert(getmetatable), assert(setmetatable)
-- I'm going to shadow these because I'll forget otherwise
local getmetatable, setmetatable = nil, nil
#/lua


#!lua
local core = require "qor:core"
local lazyloader = assert(core.module.lazyloader)
#/lua


*** lazy cluster

I'm writing cluster as a mostly-lazy system.

If anything I'll make it lazier over time.  Much of what is created in this
source file relies on a set of common upvalues holding weak references, more
on that later.


#!lua
local cluster = lazyloader { 'cluster',
                   response = "cluster:response",
                   mold     = "cluster:mold",
                   contract = "cluster:contract",
                   -- clade = "cluster:clade",
                   -- G     = "cluster:G",
                }
#/lua


**** cluster weak table library

   Cluster observes everything which passes through it, by saving weak
references.

#!lua
local weak = assert(core.meta.weak)
#/lua

Seed, tape, and meta, have a sort of primitive component type, so cluster
will want to be able to tell which it might be dealing with when handed a
given table.

So we need three weak tables for this purpose:

#!lua
local is_seed, is_tape, is_meta = weak 'k', weak 'k', weak 'k'
#/lua

As a quirk, we call tapes "tape" inside cluster.  My excuse is that the
concept map from the tape-in-itself to the word "tape" is at least
translucent, and that tape-to-tape is also easy enough.  This relies on a
pun, though, and offering it to the user as a Tape would be misleading.

It is, moreover, a long word, and without going full Mencius "Procrustes"
Moldbug on our vocabulary, the trio of four-letter variables makes for
pleasing code.

The three parts being inter-related, we also map between them:

#!lua
local seed_tape, tape_seed = weak 'kv', weak 'kv'
local tape_meta, meta_tape = weak 'kv', weak 'kv'
local meta_seed, seed_meta = weak 'kv', weak 'kv'
#/lua

We want a function to do all this bookkeeping for us:

#!lua
local insert = assert(table.insert)

local function register(seed, tape, meta)
   is_seed[seed] = true
   is_tape[tape] = true
   is_meta[meta] = true
   seed_tape[seed] = tape
   tape_seed[tape] = seed
   tape_meta[tape] = meta
   meta_tape[meta] = tape
   meta_seed[meta] = seed
   seed_meta[seed] = meta
   return seed, tape, meta
end
#/lua

I'm just adding a quick note that we can call these an =observer= and
=translator= and make them methodical.


** metafor(seed), tapefor(seed)

The seed is the return value from modules, and there are occasions when we
want the metatable assigned to instances (motivating example is database
rehydration).

The tape can (usually!) be retrieved manually from the seed, but that's not
in the contract, the seed exposes "useful fields", and though we don't happen
to offer affordances for changing what that means yet, we will.  Therefore
=tapefor=.

It should be the case that the seed is a metonym for the genre in all
important cases, but clearly we can add more functions if and when we need
them.

#!lua
function cluster.metafor(seed)
   if is_seed[seed] then
      local M = seed_meta[seed]
      if M then
         return M
      else
         return nil, "seed has no metatable"
      end
   else
      return nil, "this is not a recognized seed"
   end
end

function cluster.tapefor(seed)
   if is_seed[seed] then
      local T = seed_tape[seed]
      if T then
         return T
      else
         return nil, "seed has no tape"
      end
   else
      return nil, "this is not a recognized seed"
   end
end
#/lua


** idest(pred, obj)

This is one of, if not the most, pervasive elements of Cluster.

In the near future we make this part of the global environment, which moves it
to pylon.

*NOTE the argument order*.  This is so we can easily curry =idest= to get a
specialized test.

This initial implementation does three things:

-  If =pred= is a string, it is assumed to be a primitive type.
   Warning: we may do cdata detection and use metatype stuff there, at some
   future point.

-  If the object is a table, we check 'cluster inheritance', if not

-  We fall back on old-school =meta {}= style self tables.  These are
   deprecated and may be removed; cluster will likely have a way of creating
   self-tables but it won't use the =.idEst= flag.

#!lua
local function idest(pred, obj)
   -- primitive
   if type(pred) == 'string' then
      return type(obj) == pred
   end
   -- try new-style first
   if type(obj) == 'table' then
      local _M = getmeta(obj)
      if _M and is_meta[_M] then
         while _M do
            if _M.__meta.seed == pred then
               return true
            end
            _M = _M.__meta.meta
         end
      elseif obj.idEst == pred then
         return true
      end
   end

   return false
end
cluster.idest = idest
#/lua

This will put idest in the global, which we're not doing now.

The Orbwise way to do this is to transclude the code block above into pylon.

#!lua #noKnit
rawset(getfenv(1), "idest", idest)
#/lua


** Order, Genus, and Species

  Rather than fall into the taxonomic fallacy, providing levels and sublevels
which organize thought rather than reality, we have the concepts of order,
genus, and species, which are collectively genres.

An order is always a basis, which may be instantiated, and may also be
extended via =cluster.genus=.  A genre with no further specializations is a
species; a genus has both generic and specific partners.

An instance of a given genre we refer to as a subject, or instance, but never
as an object, except in that rare case where we refer to it as a C struct.

In the current version, species is not a load-bearing concept.  It stops being
a species if specialized, while changing not at all in structure.  Any species
in turn is also one of genus or order, leaving us with little need to refer to
a genre this way.

I'm keeping it for a couple reasons; the concept lets us speak of genres
as "generic to" and "specific from" another genre, and we may find species
itself meaningful in the context of coalescence, something we don't actually
do yet.


*** Contract

The contract determines the exception.

When mature, all operations and variations within cluster will be available
by contract.  For example, a field =construct= on the contract will expect
the same value as the second argument of =cluster.construct=.

This is a good convention and might end up part of the protocol: aspects of
the contract which /can/ be applied later, are make available via the same
name on cluster, with the seed as the first argument.

The contract should be identical between order and genus, insofar as possible.

Since the contract is optional, and never leaves Cluster, we may as well
provide a single base case:

#!lua
local CONTRACT_DEFAULT = {}
#/lua


**** Function Seeds

By convention, we make the seed a callable table.

This is the most useful default: it gives access to the Tape, from both the
return value, and during construction.  When this is useful, we're happy about
it, and it otherwise stays out of the way.  The convention of calling the
Tape =Widget= and the seed =new=, returning the seed, and calling that same
object =Widget= in another module, is justified in being generally able to
index the same values on the Seed and Tape.

It's not a requirement, and there are cases where we want the builder to be
an ordinary function.

The slot =cfg.seed_fn= tells Cluster to use that function as the builder,
wrapping it in a closure which sets the appropriate metatable.  This, and
not a table, is registered and returned as the Seed.

This has implications, the most important being that Cluster needs to avoid
trying to index the Seed, and must check type if it wants to do that.


**** Function indices

  Our sensible default is that an order will have a table index, which is
identical to the Tape.  Cluster will handle function indices as well in
at least two ways: =.boundindex= and =.freeindex=.

A =boundindex= function must be of three arguments, =(Tape, key, value)=,
cluster curries the tape to the index and assigns it, while putting the
Tape somewhere where it can be consulted for keys later.

The Tape with =boundindex= lives at  =__meta.keys=, where the contract is
that all values are ignored, any non-nil value returns a key, anything in a
keys table must have only index tables and this will be checked by cluster
when building.

=freeindex= is for index metamethods which do not have a table which is the
source of truth for indexing, maybe it gives the square of even numbers and
the cube root of odd ones, we don't care, but we can't look up the keys on
it and rummaging around looking for the nearest table upvalue is unlikely to
be of assistance.  It is unclear what serves as the Tape under these
circumstances.

Also an =instruments_may_index= flag, meaning that despite the scary function,
the keys which end in =__meta.keys= may be applied to that function to get a
result.  It's a promise of no side-effects.  This isn't a security thing,
it's a politeness thing; Lua is nasal demons all the way down.

Finally, there's an orthogonal question, which is whether the Tape should be
made available via inheritance on the Seed.  This is a question Cluster can't
answer, being pure user intention, and there could be cases where we don't
attach the Tape to the Seed, even when the Tape serves as an index table.


**** seedmeta

Normally, the Tape is assigned to the Seed metatable as the index, as
well as the index of the metatable proper.

=.seedmeta= can provide a table for this.  This will allow for completely
custom constructors to be passed in, though that's not the main intention.


*** [/] #Todo Refactor Contract

Cluster needs some hard thinking about how the existing pieces compose.

I'm going to finish hacking in the =seed_fn= feature, and making sure that
the consequences are handled.

The meta-issue is that more-or-less by definition, the contract can operate
all of the rest of cluster.

This leaves us with some judgement calls as to how to proceed.


**** [#Todo] Reconcile Builder and Creator

This has been partially addressed.

The observation is that the constructor doesn't care whether it's a builder or
not.

There's at least some case to be made that an order should create the subject,
but I do intend to offer something along the lines of =replacebuilder= for
cases where a genus has no need for the basal constructor.

This allows us to generate optimal code for cases where the order is
'abstract', which gets quote marks because it's user intention rather than,
you guessed it, ontology.  One can imagine other cases where the
superconstructor simply isn't germane.

There are some other useful protocols (prehooks, notably) which we can
implement for orders which use a builder rather than a creator.

But we currently have to detect this distinction when specializing, which
shouldn't be necessary.


***** [ ] Implementation

We're dealing with some fine distinctions here, briefly:

A /constructor/ is that which creates, builds, assigns a metatable to, and
returns the instance.  For proper composability, these must be constructed by
Cluster.

A /builder/ receives the subject and arguments, (presumably) decorating the
subject, and returning it, but without assignment.  For protocol consistency,
this is the default for orders, and is the only option for genera.

A /creator/ receives only arguments, and must return a subject. Cluster
doesn't care whether the subject is a passed argument or created de novo.
These may only be provided for orders.  The seed is the first argument,
unless the seed is a function.

Currently, we have two code paths for an order, depending on whether a creator
or builder is provided.

What we do here is turn an order builder into a creator, which is only
slightly tricky given that the affected parameter is the second one.

This is better, because a builder-free order can't do builder-protocol stuff,
which relies on =(seed, instance, ...)=, so the absence of a =builder= slot on
=__meta= is meaningful.


*** order(contract?)

  Cluster, in keeping with Lua's philosophy, has no equivalent of a root
object common to the system.  It is a protocol, not an ontology.

A basis genre is defined with =cluster.order=, which takes an optional
contract.


*** genus(genre: seed?, contract)

This specifies a genus, relative to a given genre.

Why genus?  The various terms of Linnean taxonomy have unwanted connotations,
class very much included.  Genus fits nicely.

It's also a reminder that we are using the techniques of prototyping and the
metaobject protocol, where class is used extensively in the sense of
classification.  Cluster is protocol, not ontology.

Last, it's a reminder that applying it repeatedly gives /generic/ results.
The relation between generic, genre, and genus, is pleasing, as is the pairing
with specific, specify, specialization, and species.

#!lua
local pairs = assert(pairs)
local closedSeed;

local ts;

local function genus(order, contract)
   ts =  ts or require "repr:repr" . ts_color
   if order then
      local meta_tape = seed_tape[order]
      if not meta_tape then
         return assert(nil, "provide seed to extend genus")
      end
      local seed_is_table = true
      contract = contract or CONTRACT_DEFAULT
      local seed;
      local tape, meta = {}, {__meta = {}}
      if contract.seed_fn then
         -- do seed_fn stuff
         seed_is_table = false
         seed = closedSeed(contract.seed_fn, meta)
      else
         seed = {}
      end
      if not seed then
         return assert(nil, "contract did not result in seed")
      end
      register(seed, tape, meta)
      if seed_is_table then
         setmeta(seed, { __index = tape })
      end
      setmeta(tape, { __index = meta_tape })
      local _M = seed_meta[order]
      if not _M then
         assert(nil, "no meta for generic party:\n"
                      --.. ts(order) .. "\n\n"
                      --.. ts(tape_seed[meta_tape])
                      )
      end
      for k, v in pairs(_M) do
         -- meta we copy
         if k == '__meta' then
            for _, __ in pairs(v) do
              meta.__meta[_] = __
            end
         else
            meta[k] = v
         end
      end
      meta.__meta.meta = _M -- ... yep.
      meta.__index = tape
      meta.__meta.seed = seed

      --print("Extension:\n", ts(seed), "\n\n", ts(tape), "\n\n", ts(meta))
      return seed, tape, meta
   else
      return nil, "genus must be called on an existing genre/order"
   end
end

cluster.genus = genus
#/lua

#!lua
local function order(contract)
   local seed_is_table = true
   contract = contract or CONTRACT_DEFAULT
   local seed, tape, meta;
   if contract.seed_fn then
      -- do seed_fn stuff
      seed_is_table = false
      meta = {__meta = {}}
      seed = closedSeed(contract.seed_fn, meta)
   else
      seed = {}
      meta = {__meta = {}}
   end
   seed, tape, meta = register(seed, {}, meta)
   if seed_is_table then
      setmeta(seed, { __index = tape })
   end
   meta.__index = tape
   meta.__meta.seed = seed
   return seed, tape, meta
end

cluster.order = order
#/lua


**** closedSeed(seed_fn, meta)

We use this when we need the seed to be a function, not a callable table.

Note that this is expected to create the subject table.

How to handle extension is an open question, but the signature of the
extension kinda /has to/ be =(subject, ...)= to account for cases where the
subject is created within, not passed.

#!lua
function closedSeed(seed_fn, meta)
   return function(...)
      local subject, err = seed_fn(...)
      if subject then
         return setmetatable(subject, meta), err
      else
         return subject, err
      end
   end
end
#/lua


*** construct(seed, builder)

Before a Cluster order or genus can be used, it *must* be provided with a
constructor.  Even if the original constructor of a genus is to be reused,
=extendbuilder= needs to be called with =true=.


**** Signature of builder: builder(seed, instance, ...) -> instance, extra

In order to successfully extend builders, they can neither create the instance
nor assign it a metatable.  We allow creation for orders, but not genera, via
=create= (see below).

The result of calling =construct= is a callable with the signature
=(seed, ...) -> Instance =, so the builder signature is
=(seed, instance, ...) -> instance=.

The builder *must not* assign a metatable, because the JIT relies on immutable
table/metatable relationships, and even if it didn't, assigning an
intermediate metatable which is never used is sloppy engineering.

The seed and the metatable have the same index[{†}], so it's possible to use
values from the tape during building, whether that's a good idea or not
(and it can be, as a way to design a more-generic builder which dispatches on
qualities of genera which may not be known).

{†}:  When the seed is a table.  When it isn't, it's not in the signature.

The user must bear in mind that selecting slots from the seed means that
extensions *will* be able to change the values.  The builder function is
normally defined with all three aspects of an order in scope, making it
possible to capture values from the base if this is correct.

Cluster takes care of making the builder into a constructor, by making the
instance table, and composing an assignment of the metatable with the builder
function.

This separation lets us re-use the builder in specializing a given genus, if
we want to, without performing the forbidden double-metatable assignment.

We return a second value =extra=, for various good reasons.  We already
collect a second value for error purposes, and it seems rude not to offer that
value back after assigning the metatable to the first return.

This is all that's needed if a second return value is desireable, and allows
smuggling anything one would like out in the rare event that more return
values would be natural.


***** Component Closures

  We build the constructor in the necessary pieces for composability, and
trust the heavily-biased traces to eliminate the intermediate work in hot
code.

#!lua
local fn = core.fn
local curry, iscallable = assert(fn.curry), assert(fn.iscallable)
#/lua


****** endow(meta, subject, err): Subject

Simply passes through errors, and sets a metatable when it gets a chance.

The order lets us catch both return values of a builder from an inline call,
as well as curry the metatable if that proves useful.


#!lua
local function endow(meta, subject, err)
   if subject == nil then
      return nil, err or "builder must return the subject"
   else
      return setmeta(subject, meta), err
   end
end
#/lua


****** creatorbuilder(builder): creator: (seed: Seed, ...): t :t

  Returns a closure which creates an empty table for the second argument to
=builder=.

#!lua
local function creatorbuilder(builder)
   return function(seed, ...)
      return builder(seed, {}, ...)
   end
end
#/lua


****** makeconstructor(builder, meta)

Stitches the aforementioned into a constructor.

#!lua
local function makeconstructor(builder, meta)
   local creator = creatorbuilder(builder)
   return function(seed, ...)
      return endow(meta, creator(seed, ...))
   end, creator
end

local function construct(seed, builder)
   assert(is_seed[seed], "#1 to construct must be a seed")
   assert(iscallable(builder), "#2 to construct must be callable")
   local meta = assert(seed_meta[seed], "missing metatable for seed!")
   meta.__meta.builder = builder
   getmeta(seed).__call, meta.__meta.creator = makeconstructor(builder, meta)

   return true
end

cluster.construct = construct
#/lua

Here we see how using a local library of weak references can mitigate the
complexity of having three tables floating around.  We don't need to hand
back the metatable when adding the constructor, which is just an opportunity
to pass the tape by accident.

The user doesn't even have to capture the metatable if metamethods aren't
necessary: ==local new, Widget = cluster.order()== is preferred in that case.


**** cluster.create(seed, creator)

Sometimes we need to create the instance table ourselves, this is how.

This is used in e.g. Set and Message, where the content is usually provided
in a literal table, making a separate allocation and copy a waste.

A "builder" and a "creator" only differ while the constructor is under
construction, they have the same image (return a subject instance without its
metatable) and the differing domain is only relevant internally.

Every meta must have a creator, which is the composition of the order's
creator and every subsequent builder.  They may, or may not, have a builder.

#!lua
local function makecreator(creator, meta)
   return function(...)
      return endow(meta, creator(...))
   end
end

local function create(seed, creator)
   assert(is_seed[seed], "#1 to construct must be a seed")
   local meta = assert(seed_meta[seed], "missing metatable for seed!")
   meta.__meta.creator = creator
   getmeta(seed).__call = makecreator(creator, meta)
end

cluster.create = create
#/lua


**** extendbuilder(seed, builder)

  This performs the 'natural' extension of a builder function, by passing the
seed, instance, and all arguments, first to the super builder, then to the new
builder.

Note that what is extended is the creator; we don't check for a super-builder,
or need to.  Read as "extend with builder".

A =true= argument means the original creator is to be reused, but the new
metatable applied.  This is admittedly one of those out-of-band signals one
cooks up in dynamic languages.  As we build out the contract I expect it will
be the more natural idiom for this common case.

The extension clobbers any second return value from the generic builder, but
will provide the specific one, if any.  I don't see an easy way around that,
and if it comes time to write a hard one, I'll know.

#!lua
local function extendbuilder(seed, builder)
   assert(is_seed[seed], "#1 to construct must be a seed")
   local meta = assert(seed_meta[seed], "missing metatable for seed")
   -- this is where we need to check for function seeds and take a whole
   -- different branch
   local seed_M = getmeta(seed)
   local _M = meta.__meta.meta
   if not _M then
      return nil, "can't extend a constructor with no generic, use construct"
   end
   -- it's the creator which we extend, read "extend with builder"
   local gen_creator = assert(_M.__meta.creator, "metatable missing a creator")
   -- true means reuse the builder
   if builder == true then
      meta.__meta.creator = gen_creator
      seed_M.__call = makecreator(gen_creator, meta)
      return true
   end
   if not iscallable(builder) then
      return nil, "builder of type " .. type(builder) .. " is not callable"
   end

   local function creator(seed, ...)
      local subject, err = gen_creator(seed, ...)
      if not subject then
         return nil, err
      end

      return builder(seed, subject, ...)
   end

   meta.__meta.builder = builder
   meta.__meta.creator = creator
   seed_M.__call = makecreator(creator, meta)
   return true
end

cluster.extendbuilder = extendbuilder
#/lua

This interface is experimental, to put it mildly, this is just a hunch:

#!lua
cluster.extend = {}
cluster.extend.builder = extendbuilder
#/lua


*** super(tape, "message", after_method)

The signature we want is =super(tape):message(after_method)=, but let's
work our way up.

The result of calling super is to extend the method at slot =:message= by
calling the aftermethod after the super method, with the same arguments.

Note that this discards the value of the super method, which is compatible
with the chaining style and anything else where the return value may be
recomputed.  Assigning a method to come after the invocation of a given
method, one which receives the return values, is conceptually distinct and not
yet implemented.

It is an error to attempt to extend a method twice, or to extend a method
which exists on the tape itself, rather than the tape's lookup chain.

#!lua
local rawget = assert(rawget)

local function super(tape, message, after_method)
   assert(is_tape[tape], "#1 error: cluster.super extends a tape")
   assert(type(message) == 'string', "#2 must be a string")
   assert(iscallable(after_method), "#3 must be callable")
   -- let's prevent this happening twice
   if rawget(tape, message) then
      error("tape already has " .. message)
   end
   local super_method = tape[message]
   assert(iscallable(super_method), "super method value isn't callable")
   tape[message] = function(_tape, ...)
                      super_method(_tape, ...)
                      return after_method(_tape, ...)
                   end
   return;
end

cluster.super = super
cluster.extend.super = super
#/lua


**** Integration with function indices #improve

  The cluster MOP will offer a variety of extension protocols, but you'll see
a theme, which is that of pursuing a general and satisfactory single
inheritance which survives more than one round of specialization.

This relies on the tape being a reliable source of truth when looking up the
super method, which we will have to solve eventually. This is at least true
when we use the bog-standard =__index= chain of tables, and I want to write
the tricky functionalizing stuff against a need for it.


** Cluster .ur methods

These are primitive functions which provide suitable base-layer behaviors for
genera.

#!lua
local ur = {}
cluster.ur = ur
#/lua


*** mu()

This returns, regardless of argument.

#!lua
function ur.mu()
   return
end
#/lua


*** pass(...)

Returns all arguments.

#!lua
function ur.pass(...)
   return ...
end
#/lua


*** chain(a)

Returns only the first argument.

#!lua
function ur.chain(a)
   return a
end
#/lua


*** thru(_, ...), AKA through

Ignores /only/ the first argument, returning any others.

The shorter spelling is preferred, but synonyms are cheap and these two have
reference equality.

#!lua
function ur.thru(_, ...)
   return ...
end

ur.through = ur.thru
#/lua


**** NYI(!)

Throws an error if called.

#!lua
function ur.NYI()
   error "missing method!"
end
#/lua


**** yes(), no()

Respond =true= or =false= respectively.

Used to provide a /meaningful/ base response to a predicate message.  Prefer
=mu= or =NYI= if the predicate should or must be provided.

#!lua
function ur.no()
   return false
end
#/lua

#!lua
function ur.yes()
   return true
end
#/lua


#!lua
return cluster
#/lua


* Cluster Postscript

  This represents an early and unstable sketch of Cluster, which we'll continue
to describe and design below.

This is an increasingly unwieldy text dump, most of which will end up migrated
somewhere useful.

Useful here is also defined by adding more literate programming features, so
the verbiage can be punctuated with working code.


** Philosophy

> We can divide programming languages in two categories:
>
>  1) Those where arrays start at 1.
>
>  1) Those where arrays start at 0.
>
> -- Roberto Ierusalimschy, 2022-01-01

   If Lua has a flaw, it is this, and here we might even see the maestro cop
to it.

So, as we must, we [[tip our hat to Edsger Djikstra]‡], as we dive back into
the waters of Knuthian programming with Wirthian characteristics.

[‡]: https://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF


** Rationale

  Lua is a minimalist programming language.  What other dynamic-interpreted
languages tend to do with classes, Lua does with hash maps, and a clever
system which the Lua authors call "metasyntactic extension".

Moonscript is an existence proof that one may implement a familiar object
system in Lua, with good performance and reasonable developer satisfaction.

Bridge has gone in a different direction.  One strength of a minimalist
language is that you only have to pay for what you need.

Most modules in bridge follow a simple module / instance format, and we
represent this intention using a simple function called =meta=.

The basic pattern is to make a table where ==tab.__index = tab==, fill this
table with methods, define =new= to construct an instance with this metatable,
set ==tab.idEst = new==, then return it.

This gives us the necessary affordances to build, but requires shenanigans to
do even single inheritance, because we need to instantiate the module to get
at the metatable in order to extend it.

Worse, using an =.idEst= slot on the indexed metatable allows for exactly one
sort of identity.  I've lampshaded this weakness by using e.g.
==isNode = true== as a 'genus', which is adequate but not actually good;
continuing to ad-hoc our way through identity and interface is a recipe for
pain.

The goal here is to develop a meta-object protocol, which allows the user to
build various rich abstractions, while requiring only minimal changes to the
80% of modules which returns a function that assigns a metatable.


*** Moving Past Single-Inheritance Through Self Tables

  One pattern which isn't carrying its weight is what we've been calling self
tables.  These are the return value of =meta {}=, such that a sequence such
as:

#!lua #noKnit #example
Widget = meta {}

-- here we fill the widget table

SubWidget = meta(Widget)
#/lua

Will... usually give expected results.


**** A close reading of core.cluster.meta

It's worth looking at the current version of meta.  We don't have transclusions
yet, so it's copy and paste, alas.  This is /mostly/ the basis for inheritance
and instantiation patterns in bridge, although not entirely.

#!lua #noKnit #example #hashtagTranscludeMe
function cluster.meta(Meta)
   Meta = Meta or {}

   -- decoration
   if Meta
      and type(Meta) == 'table'
      and isempty(Meta) then

      Meta.__index = Meta
      return Meta
   end

   -- inheritance
   if Meta and Meta.__index then
      local tab = {}
      for field, value in next, Meta, nil do
         if sub(field, 1, 2) == "__" then
            tab[field] = value
         end
      end
      if Meta.__meta then
         tab.__meta = tab.__meta or {}
         for _, __ in next, Meta.__meta, nil do
            tab.__meta[_] = __
         end
      end
      tab.__index = tab
      return setmeta(tab, Meta)
   end

   error ("cannot make metatable from type" .. type(Meta))
end
#/lua

See that =meta= does the same thing called as =meta()=, and our preferred form
=meta {}=. I will argue that this at least is a good pattern. Instantiation
of a table without arguments looks nicer in the form =build {}=, and
=build ()= should have the same behavior.

The self-indexing pattern avoids creating a separate index table and metatable,
which in the simple module-instance pattern obscures more than it illuminates.

The statement beginning =if Meta.__meta then= is not currently used anywhere,
it's a sketch in the direction of an extension of the existing system.



***  Respect the Runtime

  Lua is a carefully designed language, and was chosen carefully by your
humble author, out of admiration for the choices which were made in this
design.

This applies even moreso to the choice of implementation, LuaJIT.  This brings
two offerings to the table: a powerful JIT and a wonderful foreign function
interface.


**** Meta-Object Protocol

  One of the attractions of Lua is that it embraces the correct definition of
"object" to use when programming anywhere near the C runtime.

This is more than just a particular layout of memory, pointer references can
make the instance of a particular object arbitrarily complex, but what an
object *is* to the C programmer needn't be defined to point out that Lua uses
it.

Clearly, associating tables with behavior is also core to the Lua philosophy,
but this is done in a way which the authors describe as metasyntactic
extension.  This is familiar to old Lisp hands as a meta-object protocol, a
set of abstractions which allow the dispatch of various messages to
appropriate responders through the same syntax used to access literal slots
on the table in question.


** Types

  Cluster progressively turns the LuaJIT runtime (with libuv and SQLite
characteristics) into a gradually typed system.

Type itself is heavily overloaded, and we have our work cut out in manifesting
something which gives us what we want with reasonable tradeoffs.

The easy to spot types in Lua are two: the first are the primitives, which are
what you get from calling =type=, plus a whole right world in the =ffi.cdef=
extension, which is from Lua's perspective just called =cdata=.

The second are what we might call relational types: any two tables which share
a common metatable are in an obvious relational harmony which can and should
be expressed through a type system.  Lua's metasyntactic extensions are a
natural fit for a certain sort of index-oriented module-and-instance pattern,
which bears up under a certain amount of careful single inheritance.


*** Angle of Attack

One of the superpowers we've unlocked with the Bridge is the ability to parse
Lua into an enriched AST within the language.  This should let us add a
fairly standard inferred type system based on the primitive Lua functions,
operators, and primitives, which is a start.

This is part of the Lun/Clu project, which is its own beast, but the Cluster
codex must be considered within that context.  What we are building is
fundamentally a set of runtime constraints on a dynamic language, designed to
allow the orthogonality of the basic primitives and concepts to compose nicely
into richer abstractions.

The intention is that this knowledge will be useful during several stages,
in order: compile time, comptime, load time, and runtime.  We necessarily work
backward toward that goal.


** Glossary

Words and concepts in the glossary are solid enough to define and refer to.

Everything which is still fluid or tentative is below, in [[Concepts]
[@#concepts]].e


*** Field

  A key/value pair, considered in terms of the *key*.  This is an efficient
rather than formal relation, that is, it is the /consequence/ of calling
=tab[field]= we are concerned with.  A field is a key if it lives on the
table being indexed, and it is by definition a key which is used to access
the corresponding value on the *slot*.  A field /defines/ the result of
=tab[field]= in right-hand positions, and /returns the lvalue/ for a statement
of the form ==tab[field] = slot==.


*** Slot

  A key/value pair, considered in terms of the *value*.  This is an efficient
rather than formal relation, that is, it is the /rvalue/ of (especially)
==tab[field] = slot== we are concerned with.  A slot may contain a value on
the table itself, or anywhere else.  It is the /return value/ of =tab[field]=
and the /rvalue/ of ==tab[field] = slot ==.


*** Message

  A **field**, correponding to a *slot* containing the function, expected to be
called with the *instance* as the first argument, normally in the sugared form
=tab:message(...)=.


*** Method

  A *callable* living on a slot of a table which is intended primarily to
receive that table as the first argument.  A **message** is to a *method* as
a **field** is to a **slot**.  The Actor framework provides a reified Message,
which is rightly seen as an extension of this concept.

We use =:message= shorthand when referring to fields which will return
methods.


** Concepts

  Cluster (rhymes with cluck) brings together a bewildering number of sources,
and out of bare necessity of discovery, I barely understand how it works now,
let alone once there is code in this repository.


*** Molds

  The question we're trying to answer with types, is what sorts of behaviors
and data a given object might contain or display.

In hoon, everyone's favorite acid trip, the mold is one of the ways of
grappling with this reality.

For our purposes, a mold is a way of constraining the rvalue of a given lvalue.
This returns either the value, which in the general case is an Any, or
=nil, condition=.  We'll talk about what conditions are and imply later, it's
a form of error, mostly.

