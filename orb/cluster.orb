* Cluster


  *The Comprehensive LUa System for Typing Everything Repeatedly*.

Cluster is the basis for using the LuaJIT runtime in the bridge-approved
fashion.  It succeeds at this, insofar as it will, by respecting the existing
[[philosophy][@#philosophy]] of the language.


***** Dev Note: House Style for Cluster

  Because Cluster is new, the interface is unstable.  To keep refactoring
simple, we don't want to follow the localizing policy which is generally in
force, and we want to require it consistently as =cluster=.  Scry isn't able
to follow even very simple assignment yet, so making all uses greppable is
going to let us refactor. =cluster.ur.pass= is distinctive; if we decided,
say, to change it to =cluster.ur.Pass=, this spares having to chase down
upvalue =ur=s.


** Concepts

  Cluster is a structural protocol, which further's Lua's primitive facilities
for metasyntactic extension.

A reader with a grounding in class-based object systems, might be forgiven for
thinking that we're talking around some basic concepts, being different for
its own sake.

This is always a risk, dear Reader.  I may hope to persuade you otherwise.

Lua is often described as a prototype language, but this misses the mark.
#tk:reference The authors readily acknowledge inspiration from Self, but
describe the metatable system as "metasyntactic extensions", as do we.

Lua instead uses a /structural/ approach to constructing a table with the
desired behavior.  If one wishes to create a prototype chain, one must do so.
The language makes this easy and fast, but doesn't require it.

Because of this structural relationship, composable complexity requires
adherence to a common form.

Cluster specifies this form, while providing an interface which ensures that
this protocol is adhered to.  It also tracks various relationships
internally, making it a framework as well as a protocol.

This basic act of registration isn't optional, and the initial implementation
treats the entire ecosystem as global state.  There is only one Cluster, not
because there /must be/ only one Cluster, but because we only need one.

As we develop Cluster so that it may itself be extended, we will assure that
all the necessary primitive operations are available piecemeal.

Cluster will need to be sensible to protocol across Lua-state boundaries,
so the notion of Clusters, plural, will need to be a cogent one.  More than
one Cluster in a single runtime is merely a special case of this.


*** Cluster Meta-Protocol

  There is a simple rule underlying the rest of Cluster, which is that all
functions return either a truthy value, or =nil, err=, where the second value
is generally a string.

This becomes important as things get intricate, because it allows us to
recover from errors without using a =pcall=.  It means mistakes in Cluster are
leaky, however, in the sense that the error caused by the return value being
=nil= will travel away from the error, losing the error itself in the process.

We mitigate this by providing a strict mode for development purposes, which
raises the return value into an assertion.

The purpose of Cluster is to construct subjects.  Subjects are a type of
object, but are not an object /per se/.

What could this possibly mean?


*** Subject and Object

When we refer to objects, we mean this in the C sense of the term.  Lua has
nine types for objects, and the =ctype= and =userdata= types embrace the rest
of types, therefore objects, as C understands them.

A string is an object, but we don't call it a "string object" or an object
when we mean, specifically, a string.  This is also true for tables, and for
tables which have metatables.

Within Cluster, we refer to a table with a Cluster-respecting metatable as a
subject.  This is sometimes called an instance, the difference is somewhat
underspecified at present.  The pattern of a function returning a table with
a metatable attached suffices to make that table an instance of that metatable,
which we obviously don't need Cluster to do.

The term instance here is a borrow from object-as-in-class languages, no sense
denying it.  We mean it differently: "in this instance", not "instance of":
this code is one instance of assigning that metatable to the table of the
instant.  It merely means that the table is associated with a particular
metatable, meaning either this metatable was set, or it will be.

It is the subject which is an instance of a genre, and using this term carries
more weight than instance.  References to a subject may be assumed to adhere
to the Cluster protocol, this may, or may not, be true of an instance.


*** Genre: Order, Genus, Species

Cluster's vocabulary originates for the most part with biology.

Clustering related behaviors into categories is unavoidably taxonomic.
Fortunately, we don't have reality to contend with, so this approach is not
fated to the same doom which has befallen the Linnean tradition.  If we say
a Panda is a sort of Racoon, we might change our mind and say it is in fact
a Bear.  In stark contract with biology, it is our saying so which makes it
the case.  If our Rougelike calls for the Quacking Panda Duck-Bear, so be it.

Rather than fall into the taxonomic fallacy, providing levels and sublevels
which organize thought rather than reality, we have the concepts of order,
genus, and species, which are collectively genres.

One of the many misfeatures Lua declines to provide is a base Object backing
all other Objects.  Cluster does not wrong this right.  Our basis for the
protocol is an order, and each is /sui generis/.

An order is always a basis, which may be instantiated, and may also be
extended via =cluster.genus=.  A genre with no further specializations is a
species; a genus has both generic and specific partners.

An instance of a given genre we refer to as a subject, or instance, but never
as an object, except when this generalization is appropriate.

A species is literally a matter of perspective, being the genre which has the
actual metatable of a given subject.  Lua, and Cluster, have no concept of a
class, let alone an abstract one, so this may be an order or a genus.  Cluster
goes further, because a module must return something, so (pending contract)
we make a constructor whether you intend to use it or not.

This makes for fluid discussion: we refer to genres as generic to and specific
of one another, to whatever necessary depth.  An order is basal.  This is
clear, and just as important, it leaves a lot of room for the weird stuff.

We'll save the details of what a call to =order= or =genus= returns for its
own section.  The important part is that, called with zero or one arguments,
depending, the result is a familiar single-inheritance system.

In the event we need parts to work differently, we provide another argument,
a plain old table called the Contract.


*** Contract

The contract determines the exception.

When mature, all operations and variations within cluster will be available
by contract.  For example, a field =construct= on the contract will expect
the same value as the second argument of =cluster.construct=.

This is a good convention and might end up part of the protocol: aspects of
the contract which /can/ be applied later, are make available via the same
name on cluster, with the seed as the first argument.

The meaning of the contract should be identical between order and genus,
insofar as possible.

Cluster will never assign to or otherwise mutate a contract, and doesn't
consider fields it doesn't understand to be errors.

A Contract should be considered first-class.  We will probably store them, so
mutating a Contract once applied should be avoided, but nor will Cluster
change its value, so building another contract from the first one is
predictable.

At present, we'll say that mutating a Contract after application is undefined,
and we may promote it to an error and not tell you.

Provided the contract is applied successfully, =genus= and =order= will each
return three values.  This tripartite arrangement of objects defines the
genre.


*** Seed, Tape, Meta

First, let's go over Lua's existing structural protocol.

The structure in this case is that of Lua's syntax.  A table is, properly
speaking, the specific object =GCtab=, a struct defined in =lj_obj.h=.  If
you want to see why we use the word object as we do, that's a great header to
read.

More broadly, a table is anything which respects the table /protocol/, which
is used to access any foreign object which isn't a function.

A table may be assigned a metatable with =setmetatable=.  A metatable is just
a table, one where the language treats certain fields with a double underscore
as special.  The most important one is =__index=, which, if the value is a
table, is used to lookup a key in the even that the instance table returns a
=nil= value.

The order here is one reason I say Lua is not a prototype language.  In
prototypes, specialization starts with the prototype.  In Lua, it is an
optional step, performed on a table which *always* is allocated empty of
value and metatable.

While it's possible to define a module as a simple table of metatable
construction, return it, define instances when we need them, and then set the
metatable, this is unbearably tedious compared to calling a function with
arguments.

So ordinary Lua code tends to return a constructor, which sets a metatable,
and usually the =__index= field of the metatable contains a table as well.

Cluster's three return values are exactly these.  The constructor we call the
*Seed*, the =__index= table is the *Tape*, and the metatable is *Meta*.

Cards on the table: the main reason for these terms is that they're all four
letters long.  I don't *cough* make a fetish out of it, but concision is good.

The seed must be a callable, that is, an object which conforms to Lua's
function protocol.  The conventional case is a table, with an anonymous
metatable containing a =__call= metamethod, which also has the Tape as the
=__index= slot's value.  The Seed is a function in several important cases,
so Cluster itself will never index a Seed.

The Tape is a table which is expected to be indexed against /in some way/ by
instances, and in the easy case, this has the usual single inheritance by
metatable pattern.  It is normally but not always the =__index= table of the
Meta.  The reference is to gene tapes, which if you know what a chromosome
is, that's close enough.

The Meta is assigned by the constructor to an instance table as the last step
in instantiating a table.  We've been doing this backward, which is
forgiveable as the clearest reading of a function, but as we'll see, this
inhibits composition, not to mention the occasional shallow bug from doing
things in the constructor which are given different meanings by the metatable.

So a completely blank canvas has these relations:

#!lua #noKnit
local Seed, Tape, Meta = setmetatable({}, {}), {}, {__meta = {}}

getmetatable(Seed).__index = Tape

Meta.__index = Tape

Meta.__meta.__seed = Seed
#/lua

Which are created internally by Cluster, and registered as a common system.

In a real program this will look more like any other day at the widget
factory:

#!lua #noKnit #Example
local new, Widget, Widget_M = cluster.order()
#/lua

After which Widget is assigned the usual collection of methods and base
values, and new is returned after a constructor is created.

A Lua module allows only one return value, which is probably the right call
despite causing some inconvenience.

Naturally, our return value is the Seed.  Here is a quirk of the Bridge house
style: on the requiring end, we load the module like so.

#!lua #noKnit #Example
local Widget = require "widget"
#/lua

So the Seed, which we always call =new= in the module, is referred to by the
name we give the Tape.

This works out nicely, since the Seed is conventionally a table, and one
devoid of values.  Indexing the Seed will therefore give any value defined on
the table of the same name.

The Seed is used as the identity of the genre.  What that means we'll be
implementing shortly.

Speaking of which!


** Cluster

Now that we know what we're building, let us begin to build it.


**** Localize All The Things

  Cluster takes the unusual step of localizing everything, even single-name
globals.  It's not unheard of elsewhere in the code, all of core /should/ be
thus.

Lua is a highly dynamic language, and such exacting care is prophylactic at
most, but small help and no harm is sufficient reason for ceremony.

Plus it gives me a chance to ;drop =table= from the end of the meta getter and
setter.

#!lua
local assert = assert
local require = assert(require)
local error   = assert(error)
local getmeta, setmeta = assert(getmetatable), assert(setmetatable)
-- I'm going to shadow these because I'll forget otherwise
local getmetatable, setmetatable = nil, nil
#/lua


**** core

This is Cluster's sole dependency.

#!lua
local core = require "qor:core"
local lazyloader = assert(core.module.lazyloader)
#/lua


*** lazy cluster

  The bridge-approved way to provide a collection of libraries is with a lazy
loader.

Without comptime, this means maintaining two sources of truth, this being the
replica:

#!lua
local cluster = lazyloader { 'cluster',
                   response = "cluster:response",
                   mold     = "cluster:mold",
                   contract = "cluster:contract",
                      clade = "cluster:clade",
                   -- G     = "cluster:G",
                }
#/lua

Bridge has no concept of private modules, so even a comptime lazy loader would
want configuration.  A blacklist is less likely to invalidate itself than a
whitelist, though.


**** cluster weak table library

   Cluster observes everything which passes through it, by saving weak
references.

Although we don't yet do so, it behooves the architecture to make this system
instantiable.

Which we do with a cabinet:

#!lua
local cab = use "cluster:cabinet" ()
#/lua

Promptly localizing everything we've just created.

Let's note that the cabinet is instantiated, and we don't expose the module
through the lazyloader.

Seed, tape, and meta, have a sort of primitive component type, so cluster
will want to be able to tell which it might be dealing with when handed a
given table.

So we need three weak tables for this purpose:

#!lua
local is_seed, is_tape, is_meta = assert(cab.is_seed),
                                  assert(cab.is_tape),
                                  assert(cab.is_meta)
#/lua

The three parts being inter-related, we also map between them:

#!lua
local seed_tape, tape_seed = assert(cab.seed_tape), assert(cab.tape_seed)
local tape_meta, meta_tape = assert(cab.tape_meta), assert(cab.meta_tape)
local meta_seed, seed_meta = assert(cab.meta_seed), assert(cab.seed_meta)
#/lua

We set all these relations at once through registration:

#!lua
local register = cab.register
#/lua

Which we call only at the end, letting us be relaxed about building a genre:
if anything goes wrong, we bail without adding anything to the system.


** tapefor(seed), metafor(seed)

The Seed being our canonical return value, we expose functions to return the
Tape and Meta given a Seed.

#!lua
cluster.tapefor = assert(cab.tapefor)
cluster.metafor = assert(cab.metafor)
#/lua


** idest(pred, obj)

This is one of, if not the most, pervasive elements of Cluster.

In the near future we make this part of the global environment, which moves it
to pylon.

*NOTE the argument order*.  This is so we can easily curry =idest= to get a
specialized test.

This initial implementation does three things:

-  If =pred= is a string, it is assumed to be a primitive type.
   Warning: we may do cdata detection and use metatype stuff there, at some
   future point.

-  If the object is a table, we check 'cluster inheritance', if not

-  We fall back on old-school =meta {}= style self tables.  These are
   deprecated and may be removed, self tables are an anti-pattern with dubious
   upsides.


**** __sunt

A subject is always of one species, metatables being what they are.

But =idest= is concerned with answering what sort of protocol a subject
adheres to, and the one thing we can count on is that, no matter how many
ways we have to describe a protocol, they will have a unique object which
serves as the identity.

In Latin, /sunt/ is the third-person, plural, present, active, indicative,
form of to be.  /Ergo/.

So the idest implementation we have here gets replaced with a =sunt= slot,
which is a constructed Set of all identities which a given subject can assume.

This gives us a sleeker, and shallower, =idest=, with less attention paid to
the nature of the predicate.

We put this on the metatable, and not the meta-metatable, for a few reasons.
Cluster should be able to re-derive =sunt= from inspection of =__meta=, and
conversely we want to abide by the results of =sunt[pred]= no matter where the
elements of the Set come from.

Being a cache, from Cluster's perspective, there's no advantage in the extra
lookup

#!lua
local function idest(pred, obj)
   if not obj then return false end
   -- primitive
   if type(pred) == 'string' then
      return type(obj) == pred
   end
   -- we can find Cluster on userdata eventually, but we need the
   -- debug flavor of getmetatable for that anyway
   local t = type(obj)
   if t == 'table' then
      local _M = getmeta(obj)
      if _M and _M.sunt then
         if _M.sunt[pred] then
            return true
         end
      elseif obj.idEst == pred then
         return true
      elseif _M and is_meta[_M] then
         -- even internal errors should not be raised but
         return assert(nil, "Cluster metatable missing identities on __sunt")
      end
   end

   return false
end

cluster.idest = idest
#/lua

This will put idest in the global, which we're not doing now.

The Orbwise way to do this is to transclude the code block above into pylon.

#!lua #noKnit
rawset(getfenv(1), "idest", idest)
#/lua


*** Construction

Our approach to constructors is necessarily fine-grained.

A /constructor/ is that which creates, builds, assigns a metatable to, and
returns the instance.  It is a callable, and either the call metamethod of the
Seed, or the Seed itself.

Assigning to the metatable dictates the way we build constructors, because we
want to assign only one metatable.  Extensibility requires that we compose a
constructor of at least two pieces, so that a genus can do more to a subject
before it's assigned the genre-appropriate meta.

A /creator/ receives only arguments, and must return a subject. Cluster
doesn't care whether the subject is a passed argument or created de novo.
These may only be provided for orders.  The seed is the first argument,
unless the seed is a function.

A /builder/ receives the subject and arguments, (presumably) decorating the
subject, and returning it, but without assignment.  For protocol consistency,
this is the default for orders, and is the only option for genera.

Builders are to be preferred even for orders, because they can be layered
arbitrarily.  Although focused on inheritance, and single inheritance at
that, this is not the only mechanism which Cluster will embrace, and in those
contexts the builder of an order can serve roles which a creator can't.

A constructor which is always passed a literal table of one argument is good
and sufficient reason to use a creator, and there are other cases where tables
get created before being constructed into a subject, or where we want subjects
to be unique based on various parameters and use a cache.

For the case where we would just make a local table, we let cluster do the
work.


**** newmeta(seed?)

This table is complex in construction, so we provide a function.

The seed is a convenience, as we don't do anything which can't be done later.


#!lua
local Set = assert(core.set)

local function newmeta(seed)
   return { __meta = {},
            __sunt = Set {seed} }
end
#/lua


*** order(contract?)

  Cluster, in keeping with Lua's philosophy, has no equivalent of a root
object common to the system.  It is a protocol, not an ontology.

A basis genre is defined with =cluster.order=, which takes an optional
contract.

A contract is applied with [[applycontract][@applycontract]], passing =nil= as
the first argument due to the absence of a generic party.


**** #Todo Better handling of defaults

We want one function which can be applied to any triplet, whether order or
genus, and regardless of contract, which sets up any relations which weren't
put in place.

We'll have to figure out empirically which of the structural relationships are
needed for the protocol and which aren't.  The rule is that subsequent
operations should never override the contract, if something in the structure
built by the contract is wrong, we must detect this during application.

Signature is =(order, seed, tape, meta)=, which returns =true= for
consistency.

#!lua
local applycontract, nameFor;

local function order(contract)
   local seed_is_table = true
   local seed, tape, meta;
   if contract then
      seed, tape, meta = applycontract(nil, contract)
      if not seed then
         -- tape -> err
         return seed, tape
      end
   else
      seed, tape = {}, {}
      meta = newmeta(seed)
      setmeta(seed, { __index = tape })
      meta.__index = tape
      meta.__meta.seed = seed
      meta.__meta.name = nameFor(contract)
   end
   return register(seed, tape, meta)
end

cluster.order = order
#/lua


*** genus(genre: seed?, contract)

This specifies a genus, relative to a given genre.

Why genus?  The various terms of Linnean taxonomy have unwanted connotations,
class very much included.  Genus fits nicely.

It's also a reminder that we are using the techniques of prototyping and the
metaobject protocol, where class is used extensively in the sense of
classification.  Cluster is protocol, not ontology.

Last, it's a reminder that applying it repeatedly gives /generic/ results.
The relation between generic, genre, and genus, is pleasing, as is the pairing
with specific, specify, specialization, and species.

#!lua
local pairs = assert(pairs)
local nilset = assert(core.table.nilset)

local function genus(order, contract)
   if not order then
      return nil, "genus must be called on an existing genre/order"
   end

   local meta_tape = seed_tape[order]
   if not meta_tape then
       return nil, "#1 is not a seed"
   end
   local _M = seed_meta[order]
   if not _M then
       return nil, "no meta for generic party"
   end
   local seed, tape, meta;
   if contract then
       seed, tape, meta = applycontract(order, contract)
       if not seed then
         -- tape -> err
         return seed, tape
       end
       if not getmeta(tape) then
          setmeta(tape, { __index = meta_tape })
       end
   else
       seed, tape = {}, {}
       meta = newmeta(seed)
       setmeta(seed, { __index = tape })
       setmeta(tape, { __index = meta_tape })
   end
   meta.__meta.name = nameFor(contract)
   meta.__meta.meta = _M -- ... yep.
   nilset(meta, "__index", tape)
   nilset(meta.__meta, "seed", seed)
   -- we probably want to move this to a function
   -- which also takes the contract
   for k, v in pairs(_M) do
       -- meta we copy
       -- we could stand to be more detailed here
       if k == '__meta' then
         for _, __ in pairs(v) do
             nilset(meta.__meta, _, __)
         end
       elseif k == '__sunt' then
         -- union of sets
         meta[k] = meta[k] + v
       else
         nilset(meta, k, v)
       end
   end

   return register(seed, tape, meta)
end

cluster.genus = genus
#/lua


*** Contract

A genre which comes with a contract is constructed entirely through this
separate pathway.

This implements the heart of Cluster's protocol.

When we get to extending =applycontract= itself, we'll have a proper MOP.

What follows are the supported extensions of the Contract.


***** Function Seeds

By convention, we make the seed a callable table.

This is the most useful default: it gives access to the Tape, from both the
return value, and during construction.  When this is useful, we're happy about
it, and it otherwise stays out of the way.  The convention of calling the
Tape =Widget= and the seed =new=, returning the seed, and calling that same
object =Widget= in another module, is justified in being generally able to
index the same values on the Seed and Tape.

It's not a requirement, and there are cases where we want the builder to be
an ordinary function.  Specifically, =lpeg= is sensitive to the type, not the
shape, of a table and function, so building AST Nodes, which is our bread and
butter, requires a function in order to be properly incorporated into pattern
userdata.

The slot =cfg.seed_fn= tells Cluster to use that function as the builder,
wrapping it in a closure which sets the appropriate metatable.  This, and
not a table, is registered and returned as the Seed.

This has implications, the most important being that Cluster needs to avoid
trying to index the Seed, and must check type if it wants to do that.


***** Function indices #NYI

  Our sensible default is that an order will have a table index, which is
identical to the Tape.  Cluster will handle function indices as well in
at least two ways: =.boundindex= and =.freeindex=.

A =boundindex= function has parameters =(tape, subject, key)=. Cluster curries
the Tape to this function, otherwise treating it normally viz. registration
and (given a Seed table!) assigning to to the Seed's index.

Furthermore, a Tape with =boundindex= lives at  =__meta.keys=, where the
contract is: values don't matter, any result (false included!) is a key, and
indexing the slots on =keys= will not cause mutation of any sort, including
=pairs=.  This lets both Cluster and helm inspect a value's slots without
triggering the function.

It's worth justifying the irregular grammar of =keys= plural, as our custom is
to write a table serving as a key/value map in the singular.  It's because
the keys are what we care about, either iterating them or copying them to an
array.

This leaves some details which call for flags.

One is =no_keys=, which is an instruction to not store the Tape on that slot.
It doesn't matter to me why someone might want to do this.  If it makes sense
to bind the Tape to a function, but not show these keys, set this flag.

Cluster is a structural protocol, and we don't register things we don't have
to.  The contract can offer a way to assign a different table for keys, but
bit-bashing it into Meta.__meta is also valid.

An =instruments_may_index= flag means that, despite the scary function, the
keys which end in =__meta.keys= may be applied to that function to get a
result.  It's a promise of no side-effects.  This isn't a security thing,
it's a politeness thing; Lua is nasal demons all the way down.

=freeindex= is for index metamethods which don't have a table which is the
source of truth for indexing.  Maybe it gives the square of even numbers and
the cube root of odd ones, we don't care, but we can't look up the keys on
it in a meaningful way.

A free index renders the Tape vestigial, but we still make one. Letting the
Tape be something which throws an error when we index it would be masochistic.


**** applycontract(genre, contract)

#!lua
local fn = core.fn
local iscallable = assert(fn.iscallable)

local closedseed;

function applycontract(genre, contract)
   local tape = {}
   local seed, meta;
   if contract.seed_fn then
      local seed_fn;
      if genre then
         local gen_meta = seed_meta[genre]
         if not gen_meta then
            return nil, "missing meta for genre"
         end
         if contract.seed_fn == true then
            seed_fn = gen_meta.__meta.creator
         else
            return nil, "extending seed builders is NYI"
         end
      else
         seed_fn = contract.seed_fn
      end
      if not iscallable(seed_fn) then
         return nil, "seed function is not callable, type "
      end
      meta = newmeta()
      seed = closedseed(seed_fn, meta)
      if not seed then
         return nil, "contract did not result in seed"
      end
      meta.__sunt[seed] = true
      meta.__meta.creator = seed_fn
   else
      seed = setmeta({}, { __index = tape })
      meta = newmeta(seed)
   end
   nilset(meta,"__index", tape)
   nilset(meta.__meta, "seed", seed)

   return seed, tape, meta
end
#/lua

#!lua
local endow;

function closedseed(seed_fn, meta)
   return function(...)
      return endow(meta, seed_fn(...))
   end
end
#/lua


**** nameFor(contract)

This ignores the contract, but overriding the default name is clearly a
contract thing.


*** Module pattern

We do this with raw lpeg because Cluster is a dependency of our parsers.

#!lua
local L = use "lpeg"
local P, C, match = L.P, L.C, L.match

local opt_project = (-P":" * 1)^1 * P":"

local dir = (-P"/" * 1) * P"/"
local leaf = opt_project^-1 * dir^0 * C(P(1)^1)
#/lua

#!lua
local getinfo = assert(debug.getinfo)
local sub, upper = string.sub, string.upper

function nameFor(contract)
   local source = getinfo(3, 'S').source
   local head = sub(source, 1, 1)
   if head == '@' then
      -- do a better job later
      local leafo = match(leaf, sub(source, 2))
      if leafo then
        return upper(sub(leafo,1,1)) .. sub(leafo, 2)
      else
        return sub(source, 2)
      end
   end
end
#/lua



*** construct(seed, builder)

Before a Cluster order or genus can be used, it *must* be provided with a
constructor.  Even if the original constructor of a genus is to be reused,
=extendbuilder= needs to be called with =true=.

Another case where contract will often be cleaner.


**** Signature of builder: builder(seed, instance, ...) -> instance, extra

In order to successfully extend builders, they can neither create the instance
nor assign it a metatable.  We allow creation for orders, but not genera, via
=create= (see below).

The result of calling =construct= is a callable with the signature
=(seed, ...) -> Instance =, so the builder signature is
=(seed, instance, ...) -> instance=.

The builder *must not* assign a metatable, because the JIT relies on immutable
table/metatable relationships, and even if it didn't, assigning an
intermediate metatable which is never used is sloppy engineering.

The seed and the metatable have the same index[{†}], so it's possible to use
values from the tape during building, whether that's a good idea or not
(and it can be, as a way to design a more-generic builder which dispatches on
qualities of genera which may not be known).

{†}:  When the seed is a table.  When it isn't, it's not in the signature.

The user must bear in mind that selecting slots from the seed means that
extensions *will* be able to change the values.  The builder function is
normally defined with all three aspects of an order in scope, making it
possible to close over references to the genre's particular Tape and Meta
when wanted.

Cluster composes a builder for an order into a creator, which is further
wrapped as the constructor.

We return a second value =extra=, for various good reasons.  We already
collect a second value for error purposes, and it seems rude not to offer that
value back after assigning the metatable to the first return.

This is all that's needed if a second return value is desireable, and allows
smuggling anything one would like out in the rare event that more return
values would be natural.


***** Component Closures

  We build the constructor in the necessary pieces for composability, and
trust the heavily-biased traces to eliminate the intermediate work in hot
code.


****** endow(meta, subject, err): Subject

Simply passes through errors, and sets a metatable when it gets a chance.

The order lets us catch both return values of a builder from an inline call,
as well as curry the metatable if that proves useful.

#!lua
function endow(meta, subject, err)
   if subject == nil then
      return nil, err or "builder must return the subject"
   elseif err == nil then
      return setmeta(subject, meta)
   else
      return setmeta(subject, meta), err
   end
end
#/lua


****** creatorbuilder(builder): creator: (seed: Seed, ...): t :t

  Returns a closure which creates an empty table for the second argument to
=builder=.

#!lua
local function creatorbuilder(builder)
   return function(seed, ...)
      return builder(seed, {}, ...)
   end
end
#/lua


****** makeconstructor(builder, meta)

Stitches the aforementioned into a constructor.

#!lua
local function makeconstructor(builder, meta)
   local creator = creatorbuilder(builder)
   return function(seed, ...)
      return endow(meta, creator(seed, ...))
   end, creator
end
#/lua

With these powers combined, we make short work of =construct= and =create=.

#!lua
local function construct(seed, builder)
   if not is_seed[seed] then
      return nil, "#1 to construct must be a seed"
   end
   if not iscallable(builder) then
      return nil, "#2 to construct must be callable"
   end
   local meta = seed_meta[seed]
   if not meta then
      return nil, "missing metatable for seed"
   end
   meta.__meta.builder = builder
   getmeta(seed).__call, meta.__meta.creator = makeconstructor(builder, meta)

   return true
end

cluster.construct = construct
#/lua


**** cluster.create(seed, creator)

Sometimes we need to create the instance table ourselves, this is how.

This is used in e.g. Set and Message, where the content is usually provided
in a literal table, making a separate allocation and copy a waste.

Every meta must have a creator, which is the composition of the order's
creator and every subsequent builder.

=create= must be called only with orders.  Let Cluster do the allocation with
a builder if you can.

#!lua
local function makecreator(creator, meta)
   return function(...)
      return endow(meta, creator(...))
   end
end

local function create(seed, creator)
   if not is_seed[seed] then
      return nil, "#1 to construct must be a seed"
   end
   local meta = seed_meta[seed]
   if not meta then
      return nil, "missing metatable for seed"
   end
   meta.__meta.creator = creator
   getmeta(seed).__call = makecreator(creator, meta)
   return true
end

cluster.create = create
#/lua


**** extendbuilder(seed, builder)

  This performs the 'natural' extension of a builder function, by passing the
seed, instance, and all arguments, first to the super builder, then to the new
builder.

Note that what is extended is the creator; we don't check for a super-builder,
or need to.  Read as "extend with builder".

A =true= argument means the original creator is to be reused, but the new
metatable applied.  This is admittedly one of those out-of-band signals one
cooks up in dynamic languages.  As we build out the contract I expect it will
be the more natural idiom for this common case.

The extension clobbers any second return value from the generic builder, but
will provide the specific one, if any.  I don't see an easy way around that,
and if it comes time to write a hard one, I'll know.

As a tip, if the specific genre calls for more arguments than the generic,
let it be one more, and make that a table.  This is much easier to handle in
the event that further specialization is called for.

#!lua
local function extendbuilder(seed, builder)
   if not is_seed[seed] then
      return nil, "#1 to construct must be a seed"
   end
   local meta = seed_meta[seed]
   if not meta then
      return nil,  "missing metatable for seed"
   end
   -- this is where we need to check for function seeds and take a whole
   -- different branch
   local seed_M = getmeta(seed)
   local _M = meta.__meta.meta
   if not _M then
      return nil, "can't extend a constructor with no generic, use construct"
   end
   -- it's the creator which we extend, read "extend with builder"
   local gen_creator = _M.__meta.creator
   if not gen_creator then
      return nil, "generic metatable missing a creator"
   end
   -- true means reuse the builder
   if builder == true then
      meta.__meta.creator = gen_creator
      seed_M.__call = makecreator(gen_creator, meta)
      return true
   end

   if not iscallable(builder) then
      return nil, "builder of type " .. type(builder) .. " is not callable"
   end

   local function creator(seed, ...)
      local subject, err = gen_creator(seed, ...)
      if not subject then
         return nil, err
      end
      return builder(seed, subject, ...), err
   end

   meta.__meta.builder = builder
   meta.__meta.creator = creator
   seed_M.__call = makecreator(creator, meta)

   return true
end

cluster.extendbuilder = extendbuilder
#/lua

This interface is experimental, to put it mildly, this is just a hunch:

#!lua
cluster.extend = {}
cluster.extend.builder = extendbuilder
#/lua


*** super(tape, "message", after_method)

#Note the newindex style of ==super(tape).message = after_method== might be
      preferable here.

  The result of calling super is to extend the method at slot =:message= by
calling the after method after the super method, with the same arguments.

Note that this discards the value of the super method, which is compatible
with the chaining style, and anything else where the return value may be
recomputed.  Assigning a method to come after the invocation of a given
method, one which receives the return values, is conceptually distinct and not
yet implemented.

It is an error to attempt to extend a method twice, or to extend a method
which exists on the tape itself, rather than the tape's lookup chain.

#!lua
local rawget = assert(rawget)

local function super(tape, message, after_method)
   if not is_tape[tape] then
      return nil, "#1 error: cluster.super extends a tape"
   end
   if type(message) ~= 'string' then
      return nil, "#2 must be a string"
   end
   if not iscallable(after_method) then
      return nil, "#3 must be callable"
   end
   -- let's prevent this happening twice
   if rawget(tape, message) then
      return nil, "tape already has " .. message
   end
   local super_method = tape[message]
   if not iscallable(super_method) then
      return nil,  "value of message ."
                    .. tape .. " isn't callable, type is "
                    .. type(super_method)
   end
   tape[message] = function(_tape, ...)
                      super_method(_tape, ...)
                      return after_method(_tape, ...)
                   end
   return true
end

cluster.super = super
cluster.extend.super = super
#/lua

That's it for the core mechanism of cluster.

There's another thousand lines of contract still to write, but meanwhile,
here's the ur methods.

These belong in their own module as well.


** Cluster .ur methods

These are primitive functions which provide suitable base-layer behaviors for
genera.

#!lua
local ur = {}
cluster.ur = ur
#/lua


*** mu()

This returns, regardless of argument.

#!lua
function ur.mu()
   return
end
#/lua


*** pass(...)

Returns all arguments.

#!lua
function ur.pass(...)
   return ...
end
#/lua


*** chain(a)

Returns only the first argument.

#!lua
function ur.chain(a)
   return a
end
#/lua


*** thru(_, ...), AKA through

Ignores /only/ the first argument, returning any others.

The shorter spelling is preferred, but synonyms are cheap and these two have
reference equality.

#!lua
function ur.thru(_, ...)
   return ...
end

ur.through = ur.thru
#/lua


**** NYI(!)

Throws an error if called.

#!lua
function ur.NYI()
   error "missing method!"
end
#/lua


**** yes(), no()

Respond =true= or =false= respectively.

Used to provide a /meaningful/ base response to a predicate message.  Prefer
=mu= or =NYI= if the predicate should or must be provided.

#!lua
function ur.no()
   return false
end
#/lua

#!lua
function ur.yes()
   return true
end
#/lua


#!lua
return cluster
#/lua


* Cluster Postscript

  This represents an early and unstable sketch of Cluster, which we'll continue
to describe and design below.

This is an increasingly unwieldy text dump, most of which will end up migrated
somewhere useful.

Useful here is also defined by adding more literate programming features, so
the verbiage can be punctuated with working code.


** Philosophy

> We can divide programming languages in two categories:
>
>  1) Those where arrays start at 1.
>
>  1) Those where arrays start at 0.
>
> -- Roberto Ierusalimschy, 2022-01-01

   If Lua has a flaw, it is this, and here we might even see the maestro cop
to it.

So, as we must, we [[tip our hat to Edsger Djikstra]‡], as we dive back into
the waters of Knuthian programming with Wirthian characteristics.

[‡]: https://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF


** Rationale

  Lua is a minimalist programming language.  What other dynamic-interpreted
languages tend to do with classes, Lua does with hash maps, and a clever
system which the Lua authors call "metasyntactic extension".

Moonscript is an existence proof that one may implement a familiar object
system in Lua, with good performance and reasonable developer satisfaction.

Bridge has gone in a different direction.  One strength of a minimalist
language is that you only have to pay for what you need.

Most modules in bridge follow a simple module / instance format, and we
represent this intention using a simple function called =meta=.

The basic pattern is to make a table where ==tab.__index = tab==, fill this
table with methods, define =new= to construct an instance with this metatable,
set ==tab.idEst = new==, then return it.

This gives us the necessary affordances to build, but requires shenanigans to
do even single inheritance, because we need to instantiate the module to get
at the metatable in order to extend it.

Worse, using an =.idEst= slot on the indexed metatable allows for exactly one
sort of identity.  I've lampshaded this weakness by using e.g.
==isNode = true== as a 'genus', which is adequate but not actually good;
continuing to ad-hoc our way through identity and interface is a recipe for
pain.

The goal here is to develop a meta-object protocol, which allows the user to
build various rich abstractions, while requiring only minimal changes to the
80% of modules which returns a function that assigns a metatable.


*** Moving Past Single-Inheritance Through Self Tables

  One pattern which isn't carrying its weight is what we've been calling self
tables.  These are the return value of =meta {}=, such that a sequence such
as:

#!lua #noKnit #example
Widget = meta {}

-- here we fill the widget table

SubWidget = meta(Widget)
#/lua

Will... usually give expected results.


**** A close reading of core.cluster.meta

It's worth looking at the current version of meta.  We don't have transclusions
yet, so it's copy and paste, alas.  This is /mostly/ the basis for inheritance
and instantiation patterns in bridge, although not entirely.

#!lua #noKnit #example #hashtagTranscludeMe
function cluster.meta(Meta)
   Meta = Meta or {}

   -- decoration
   if Meta
      and type(Meta) == 'table'
      and isempty(Meta) then

      Meta.__index = Meta
      return Meta
   end

   -- inheritance
   if Meta and Meta.__index then
      local tab = {}
      for field, value in next, Meta, nil do
         if sub(field, 1, 2) == "__" then
            tab[field] = value
         end
      end
      if Meta.__meta then
         tab.__meta = tab.__meta or {}
         for _, __ in next, Meta.__meta, nil do
            tab.__meta[_] = __
         end
      end
      tab.__index = tab
      return setmeta(tab, Meta)
   end

   error ("cannot make metatable from type" .. type(Meta))
end
#/lua

See that =meta= does the same thing called as =meta()=, and our preferred form
=meta {}=. I will argue that this at least is a good pattern. Instantiation
of a table without arguments looks nicer in the form =build {}=, and
=build ()= should have the same behavior.

The self-indexing pattern avoids creating a separate index table and metatable,
which in the simple module-instance pattern obscures more than it illuminates.

The statement beginning =if Meta.__meta then= is not currently used anywhere,
it's a sketch in the direction of an extension of the existing system.



***  Respect the Runtime

  Lua is a carefully designed language, and was chosen carefully by your
humble author, out of admiration for the choices which were made in this
design.

This applies even moreso to the choice of implementation, LuaJIT.  This brings
two offerings to the table: a powerful JIT and a wonderful foreign function
interface.


**** Meta-Object Protocol

  One of the attractions of Lua is that it embraces the correct definition of
"object" to use when programming anywhere near the C runtime.

This is more than just a particular layout of memory, pointer references can
make the instance of a particular object arbitrarily complex, but what an
object *is* to the C programmer needn't be defined to point out that Lua uses
it.

Clearly, associating tables with behavior is also core to the Lua philosophy,
but this is done in a way which the authors describe as metasyntactic
extension.  This is familiar to old Lisp hands as a meta-object protocol, a
set of abstractions which allow the dispatch of various messages to
appropriate responders through the same syntax used to access literal slots
on the table in question.


** Types

  Cluster progressively turns the LuaJIT runtime (with libuv and SQLite
characteristics) into a gradually typed system.

Type itself is heavily overloaded, and we have our work cut out in manifesting
something which gives us what we want with reasonable tradeoffs.

The easy to spot types in Lua are two: the first are the primitives, which are
what you get from calling =type=, plus a whole right world in the =ffi.cdef=
extension, which is from Lua's perspective just called =cdata=.

The second are what we might call relational types: any two tables which share
a common metatable are in an obvious relational harmony which can and should
be expressed through a type system.  Lua's metasyntactic extensions are a
natural fit for a certain sort of index-oriented module-and-instance pattern,
which bears up under a certain amount of careful single inheritance.


*** Angle of Attack

One of the superpowers we've unlocked with the Bridge is the ability to parse
Lua into an enriched AST within the language.  This should let us add a
fairly standard inferred type system based on the primitive Lua functions,
operators, and primitives, which is a start.

This is part of the Lun/Clu project, which is its own beast, but the Cluster
codex must be considered within that context.  What we are building is
fundamentally a set of runtime constraints on a dynamic language, designed to
allow the orthogonality of the basic primitives and concepts to compose nicely
into richer abstractions.

The intention is that this knowledge will be useful during several stages,
in order: compile time, comptime, load time, and runtime.  We necessarily work
backward toward that goal.


** Glossary

Words and concepts in the glossary are solid enough to define and refer to.

Everything which is still fluid or tentative is below, in [[Concepts]
[@#concepts]].e


*** Field

  A key/value pair, considered in terms of the *key*.  This is an efficient
rather than formal relation, that is, it is the /consequence/ of calling
=tab[field]= we are concerned with.  A field is a key if it lives on the
table being indexed, and it is by definition a key which is used to access
the corresponding value on the *slot*.  A field /defines/ the result of
=tab[field]= in right-hand positions, and /returns the lvalue/ for a statement
of the form ==tab[field] = slot==.


*** Slot

  A key/value pair, considered in terms of the *value*.  This is an efficient
rather than formal relation, that is, it is the /rvalue/ of (especially)
==tab[field] = slot== we are concerned with.  A slot may contain a value on
the table itself, or anywhere else.  It is the /return value/ of =tab[field]=
and the /rvalue/ of ==tab[field] = slot ==.


*** Message

  A **field**, correponding to a *slot* containing the function, expected to be
called with the *instance* as the first argument, normally in the sugared form
=tab:message(...)=.


*** Method

  A *callable* living on a slot of a table which is intended primarily to
receive that table as the first argument.  A **message** is to a *method* as
a **field** is to a **slot**.  The Actor framework provides a reified Message,
which is rightly seen as an extension of this concept.

We use =:message= shorthand when referring to fields which will return
methods.


** Concepts

  Cluster (rhymes with cluck) brings together a bewildering number of sources,
and out of bare necessity of discovery, I barely understand how it works now,
let alone once there is code in this repository.


*** Molds

  The question we're trying to answer with types, is what sorts of behaviors
and data a given object might contain or display.

In hoon, everyone's favorite acid trip, the mold is one of the ways of
grappling with this reality.

For our purposes, a mold is a way of constraining the rvalue of a given lvalue.
This returns either the value, which in the general case is an Any, or
=nil, condition=.  We'll talk about what conditions are and imply later, it's
a form of error, mostly.
